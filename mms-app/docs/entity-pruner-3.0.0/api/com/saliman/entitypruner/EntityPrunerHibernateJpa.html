<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<!--NewPage-->
<HTML>
<HEAD>
<!-- Generated by javadoc (build 1.6.0_14) on Sat Dec 10 11:42:46 MST 2011 -->
<TITLE>
EntityPrunerHibernateJpa (Entity Pruner Javadoc)
</TITLE>

<META NAME="date" CONTENT="2011-12-10">

<LINK REL ="stylesheet" TYPE="text/css" HREF="../../../stylesheet.css" TITLE="Style">

<SCRIPT type="text/javascript">
function windowTitle()
{
    if (location.href.indexOf('is-external=true') == -1) {
        parent.document.title="EntityPrunerHibernateJpa (Entity Pruner Javadoc)";
    }
}
</SCRIPT>
<NOSCRIPT>
</NOSCRIPT>

</HEAD>

<BODY BGCOLOR="white" onload="windowTitle();">
<HR>


<!-- ========= START OF TOP NAVBAR ======= -->
<A NAME="navbar_top"><!-- --></A>
<A HREF="#skip-navbar_top" title="Skip navigation links"></A>
<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0" SUMMARY="">
<TR>
<TD COLSPAN=2 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
<A NAME="navbar_top_firstrow"><!-- --></A>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3" SUMMARY="">
  <TR ALIGN="center" VALIGN="top">
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../com/saliman/entitypruner/package-summary.html"><FONT CLASS="NavBarFont1"><B>Package</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell1Rev"> &nbsp;<FONT CLASS="NavBarFont1Rev"><B>Class</B></FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="class-use/EntityPrunerHibernateJpa.html"><FONT CLASS="NavBarFont1"><B>Use</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-tree.html"><FONT CLASS="NavBarFont1"><B>Tree</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../deprecated-list.html"><FONT CLASS="NavBarFont1"><B>Deprecated</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../index-all.html"><FONT CLASS="NavBarFont1"><B>Index</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../help-doc.html"><FONT CLASS="NavBarFont1"><B>Help</B></FONT></A>&nbsp;</TD>
  </TR>
</TABLE>
</TD>
<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>
<h3>Entiy Pruner</h3></EM>
</TD>
</TR>

<TR>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
&nbsp;<A HREF="../../../com/saliman/entitypruner/EntityPruner.html" title="interface in com.saliman.entitypruner"><B>PREV CLASS</B></A>&nbsp;
&nbsp;<A HREF="../../../com/saliman/entitypruner/EntityUtil.html" title="class in com.saliman.entitypruner"><B>NEXT CLASS</B></A></FONT></TD>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
  <A HREF="../../../index.html?com/saliman/entitypruner/EntityPrunerHibernateJpa.html" target="_top"><B>FRAMES</B></A>  &nbsp;
&nbsp;<A HREF="EntityPrunerHibernateJpa.html" target="_top"><B>NO FRAMES</B></A>  &nbsp;
&nbsp;<SCRIPT type="text/javascript">
  <!--
  if(window==top) {
    document.writeln('<A HREF="../../../allclasses-noframe.html"><B>All Classes</B></A>');
  }
  //-->
</SCRIPT>
<NOSCRIPT>
  <A HREF="../../../allclasses-noframe.html"><B>All Classes</B></A>
</NOSCRIPT>


</FONT></TD>
</TR>
<TR>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
  SUMMARY:&nbsp;NESTED&nbsp;|&nbsp;FIELD&nbsp;|&nbsp;<A HREF="#constructor_summary">CONSTR</A>&nbsp;|&nbsp;<A HREF="#method_summary">METHOD</A></FONT></TD>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
DETAIL:&nbsp;FIELD&nbsp;|&nbsp;<A HREF="#constructor_detail">CONSTR</A>&nbsp;|&nbsp;<A HREF="#method_detail">METHOD</A></FONT></TD>
</TR>
</TABLE>
<A NAME="skip-navbar_top"></A>
<!-- ========= END OF TOP NAVBAR ========= -->

<HR>
<!-- ======== START OF CLASS DATA ======== -->
<H2>
<FONT SIZE="-1">
com.saliman.entitypruner</FONT>
<BR>
Class EntityPrunerHibernateJpa</H2>
<PRE>
java.lang.Object
  <IMG SRC="../../../resources/inherit.gif" ALT="extended by "><B>com.saliman.entitypruner.EntityPrunerHibernateJpa</B>
</PRE>
<DL>
<DT><B>All Implemented Interfaces:</B> <DD><A HREF="../../../com/saliman/entitypruner/EntityPruner.html" title="interface in com.saliman.entitypruner">EntityPruner</A></DD>
</DL>
<HR>
<DL>
<DT><PRE>public class <B>EntityPrunerHibernateJpa</B><DT>extends java.lang.Object<DT>implements <A HREF="../../../com/saliman/entitypruner/EntityPruner.html" title="interface in com.saliman.entitypruner">EntityPruner</A></DL>
</PRE>

<P>
This class provides an implementation of the <A HREF="../../../com/saliman/entitypruner/EntityPruner.html" title="interface in com.saliman.entitypruner"><CODE>EntityPruner</CODE></A> for 
 applications using JPA and Hibernate.  It is intended to be used as a 
 stateless session bean inside a Java EE container like GlassFish.
 <p>
 Entities must implement the <A HREF="../../../com/saliman/entitypruner/PrunableEntity.html" title="interface in com.saliman.entitypruner"><CODE>PrunableEntity</CODE></A> interface to be pruned
 with this class.  This implementation is designed to work with entities 
 that annotated at a field level.  It will still try to prune entities 
 annotated at a method level, but you probably won't be very happy with the 
 results.
 <p>
 This class is heavily dependent on the JPA provider and the types of
 collections Entities have.  This implementation only works with Hibernate, 
 and at the moment, child collections must be either a <code>Set</code>,
 <code>SortedSet</code> or <code>List</code>.  In Addition, the entities 
 must use field annotations and not method annotations.
 <p>
 Since the EntityPruner logs its activity, we recommend Entities implement
 a <code>toString()</code> method.
<P>

<P>
<DL>
<DT><B>Author:</B></DT>
  <DD>Steven C. Saliman</DD>
<DT><B>See Also:</B><DD><A HREF="../../../com/saliman/entitypruner/PrunableEntity.html" title="interface in com.saliman.entitypruner"><CODE>PrunableEntity</CODE></A></DL>
<HR>

<P>

<!-- ======== CONSTRUCTOR SUMMARY ======== -->

<A NAME="constructor_summary"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>Constructor Summary</B></FONT></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><B><A HREF="../../../com/saliman/entitypruner/EntityPrunerHibernateJpa.html#EntityPrunerHibernateJpa()">EntityPrunerHibernateJpa</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
</TABLE>
&nbsp;
<!-- ========== METHOD SUMMARY =========== -->

<A NAME="method_summary"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>Method Summary</B></FONT></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/saliman/entitypruner/EntityPrunerHibernateJpa.html#prune(com.saliman.entitypruner.PrunableEntity)">prune</A></B>(<A HREF="../../../com/saliman/entitypruner/PrunableEntity.html" title="interface in com.saliman.entitypruner">PrunableEntity</A>&nbsp;entity)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Prune the given entity to prepare it for serializing for RMI, or
 Marshalling to XML for SOAP or REST.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/saliman/entitypruner/EntityPrunerHibernateJpa.html#prune(com.saliman.entitypruner.PrunableEntity, int)">prune</A></B>(<A HREF="../../../com/saliman/entitypruner/PrunableEntity.html" title="interface in com.saliman.entitypruner">PrunableEntity</A>&nbsp;entity,
      int&nbsp;depth)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Prune the given entity to prepare it for serializing for RMI, or
 Marshalling to XML for SOAP or REST.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/saliman/entitypruner/EntityPrunerHibernateJpa.html#prune(com.saliman.entitypruner.PrunableEntity, java.util.Map)">prune</A></B>(<A HREF="../../../com/saliman/entitypruner/PrunableEntity.html" title="interface in com.saliman.entitypruner">PrunableEntity</A>&nbsp;entity,
      java.util.Map&lt;java.lang.String,java.lang.String&gt;&nbsp;options)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Prune the given entity to prepare it for serializing for RMI, or
 Marshalling to XML for SOAP or REST.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/saliman/entitypruner/EntityPrunerHibernateJpa.html#unprune(com.saliman.entitypruner.PrunableEntity)">unprune</A></B>(<A HREF="../../../com/saliman/entitypruner/PrunableEntity.html" title="interface in com.saliman.entitypruner">PrunableEntity</A>&nbsp;entity)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Un-prune the given entity so it can be saved by Hibernate.</TD>
</TR>
</TABLE>
&nbsp;<A NAME="methods_inherited_from_class_java.lang.Object"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#EEEEFF" CLASS="TableSubHeadingColor">
<TH ALIGN="left"><B>Methods inherited from class java.lang.Object</B></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE>clone, equals, finalize, getClass, hashCode, notify, notifyAll, toString, wait, wait, wait</CODE></TD>
</TR>
</TABLE>
&nbsp;
<P>

<!-- ========= CONSTRUCTOR DETAIL ======== -->

<A NAME="constructor_detail"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="1"><FONT SIZE="+2">
<B>Constructor Detail</B></FONT></TH>
</TR>
</TABLE>

<A NAME="EntityPrunerHibernateJpa()"><!-- --></A><H3>
EntityPrunerHibernateJpa</H3>
<PRE>
public <B>EntityPrunerHibernateJpa</B>()</PRE>
<DL>
</DL>

<!-- ============ METHOD DETAIL ========== -->

<A NAME="method_detail"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="1"><FONT SIZE="+2">
<B>Method Detail</B></FONT></TH>
</TR>
</TABLE>

<A NAME="prune(com.saliman.entitypruner.PrunableEntity)"><!-- --></A><H3>
prune</H3>
<PRE>
public void <B>prune</B>(<A HREF="../../../com/saliman/entitypruner/PrunableEntity.html" title="interface in com.saliman.entitypruner">PrunableEntity</A>&nbsp;entity)</PRE>
<DL>
<DD>Prune the given entity to prepare it for serializing for RMI, or
 Marshalling to XML for SOAP or REST. It is very important that this 
 happens outside a transaction, otherwise the JPA provider will assume
 that changes made during pruning need to be saved.  This is not a 
 problem in a Spring based application, because Spring will only create 
 the transaction when it is told, but EJB containers, such as GlassFish, 
 will create a default transaction when the service endpoint is invoked, 
 unless the 
 <code>TransactionAttribute(TransactionAttributeType.NOT_SUPPORTED)<code> 
 annotation is present.  This method will suspend any current 
 transaction, but it is undefined what would happen if the pruned 
 entity is used by callers that are in an active transaction.<br>
 In unit tests, the EntityManager.clear method should be called to make
 sure we are dealing with detached entities.
 Pruning basically means 3 things:<br>
 1) replacing Hibernate proxy objects with either their non proxy 
    equivalents (if they have been initialized), or <code>null</code> (if 
    they haven't)  This will prevent 
    <code>LazyInitializationException</code> when entities are serialized.<br> 
 2) Removal of circular references. This method tries to detect 
    bidirectional associations, and when found, the child's parent
    reference is set to null to prevent XML serialization problems.
    This method uses the persistence annotations to detect these 
    bidirectional associations, which means that if an entity contains
    a <code>Transient</code> collection of entities that refer back to
    the parent, the circular reference will remain.  It is up to the
    caller to make sure we don't try to prune these kinds of entities.
 3) Recursive pruning of parent entities, and each entity in a collection.
 <p>
 Note that this method only de-proxies attributes of the entity, not the
 entity itself.  This could lead to unexpected results in the client
 if, for some reason, the base entity is a proxy.
 <p>
 Once an entity is pruned, it is no longer possible to access 
 lazy-loaded collections, even if the entity is un-pruned later.
 <p>
 Pruning an entity does not save the entity's old collections in any 
 way. It is up to the caller to make a copy of the object's collections
 before calling <code>prune</code>, if access to the original 
 collections is needed.
<P>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE><A HREF="../../../com/saliman/entitypruner/EntityPruner.html#prune(com.saliman.entitypruner.PrunableEntity)">prune</A></CODE> in interface <CODE><A HREF="../../../com/saliman/entitypruner/EntityPruner.html" title="interface in com.saliman.entitypruner">EntityPruner</A></CODE></DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>entity</CODE> - the <A HREF="../../../com/saliman/entitypruner/PrunableEntity.html" title="interface in com.saliman.entitypruner"><CODE>PrunableEntity</CODE></A> to pruned
<DT><B>Throws:</B>
<DD><CODE>java.lang.IllegalStateException</CODE> - if there is a problem.</DL>
</DD>
</DL>
<HR>

<A NAME="prune(com.saliman.entitypruner.PrunableEntity, int)"><!-- --></A><H3>
prune</H3>
<PRE>
public void <B>prune</B>(<A HREF="../../../com/saliman/entitypruner/PrunableEntity.html" title="interface in com.saliman.entitypruner">PrunableEntity</A>&nbsp;entity,
                  int&nbsp;depth)</PRE>
<DL>
<DD>Prune the given entity to prepare it for serializing for RMI, or
 Marshalling to XML for SOAP or REST. It is very important that this 
 happens outside a transaction, otherwise the JPA provider will assume
 that changes made during pruning need to be saved.  This is not a 
 problem in a Spring based application, because Spring will only create 
 the transaction when it is told, but EJB containers, such as GlassFish,
 will create a default transaction when the service endpoint is invoked, 
 unless the 
 <code>TransactionAttribute(TransactionAttributeType.NEVER)<code> 
 annotation is present in the endpoint class.<br>
 In unit tests, the EntityManager.clear method should be called to make
 sure we are dealing with detached entities.
 Pruning basically means 3 things:<br>
 1) replacing proxy objects with either their non proxy equivalents (f
    they have been initialized), or <code>null</code> (if they haven't)
    <br>
 2) Removal of circular references. This method tries to detect 
    bidirectional associations, and when found, the child's parent
    reference is set to null to prevent XML serialization problems.
 3) Recursive pruning of parent entities, and each entity in a collection.
 <p>
 Note that once an entity is pruned, it is no longer possible to 
 access lazy-loaded collections, even if the entity is un-pruned later.
 <p>
 Also note that pruning an entity does not save the entity's old 
 collections in any way. It is up to the caller to make a copy of the
 object's collections before calling <code>prune</code>, if access to 
 the original collections is needed.
 <p>
 This version of the <code>prune</code> method can also be used to
 specify a maximum depth for the object.  This is handy in the case 
 where the client only needs so many levels of an object, but more 
 levels were populated by the server in the course of its actions inside
 the transaction.  Note that only a collection constitutes a level, so
 if an entity has an instance of another entity, both will be 
 pruned and returned.
<P>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE><A HREF="../../../com/saliman/entitypruner/EntityPruner.html#prune(com.saliman.entitypruner.PrunableEntity, int)">prune</A></CODE> in interface <CODE><A HREF="../../../com/saliman/entitypruner/EntityPruner.html" title="interface in com.saliman.entitypruner">EntityPruner</A></CODE></DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>entity</CODE> - the <A HREF="../../../com/saliman/entitypruner/PrunableEntity.html" title="interface in com.saliman.entitypruner"><CODE>PrunableEntity</CODE></A> to pruned<DD><CODE>depth</CODE> - the depth to populate to.  1 for just the entity, 2 for
        children, etc.
<DT><B>Throws:</B>
<DD><CODE>java.lang.IllegalStateException</CODE> - if there is a problem.</DL>
</DD>
</DL>
<HR>

<A NAME="prune(com.saliman.entitypruner.PrunableEntity, java.util.Map)"><!-- --></A><H3>
prune</H3>
<PRE>
public void <B>prune</B>(<A HREF="../../../com/saliman/entitypruner/PrunableEntity.html" title="interface in com.saliman.entitypruner">PrunableEntity</A>&nbsp;entity,
                  java.util.Map&lt;java.lang.String,java.lang.String&gt;&nbsp;options)</PRE>
<DL>
<DD>Prune the given entity to prepare it for serializing for RMI, or
 Marshalling to XML for SOAP or REST. It is very important that this 
 happens outside a transaction, otherwise the JPA provider will assume
 that changes made during pruning need to be saved.  This is not a 
 problem in a Spring based application, because Spring will only create 
 the transaction when it is told, but EJB containers, such as GlassFish,
 will create a default transaction when the service endpoint is invoked, 
 unless the 
 <code>TransactionAttribute(TransactionAttributeType.NEVER)<code> 
 annotation is present in the endpoint class.<br>
 In unit tests, the EntityManager.clear method should be called to make
 sure we are dealing with detached entities.
 Pruning basically means 3 things:<br>
 1) replacing proxy objects with either their non proxy equivalents (f
    they have been initialized), or <code>null</code> (if they haven't)
    <br>
 2) Removal of circular references. This method tries to detect 
    bidirectional associations, and when found, the child's parent
    reference is set to null to prevent XML serialization problems.
 3) Recursive pruning of parent entities, and each entity in a collection.
 <p>
 Note that once an entity is pruned, it is no longer possible to 
 access lazy-loaded collections, even if the entity is un-pruned later.
 <p>
 Also note that pruning an entity does not save the entity's old 
 collections in any way. It is up to the caller to make a copy of the
 object's collections before calling <code>prune</code>, if access to 
 the original collections is needed.
 <p>
 This version of the <code>prune</code> method can also be used to
 specify a maximum depth for the object, and options with specific
 attributes or collections to be included in the pruned object.  This is
 handy in the case where the client only needs certain parts of an 
 object, but more levels and attributes were populated by the server in 
 the course of its actions inside the transaction. Note that only a 
 collection constitutes a level, so if an entity has an instance of 
 another entity, both will be pruned and returned.  The options map is
 patterned after Ruby on Rails patterns for fetching data.  At the 
 moment, the EntityPruner supports the following options in the options
 map:<br>
 <code>include</code> a comma separated list of child collections to
 include in the results.  If null, all children will be loaded.<br>
 <code>select</code> a comma separated list of attributes to include
 in the results.  Having the names of a collection in the select option
 will have no effect on the results.  If there are no selects, all
 attributes will be loaded.<br>
 <code>depth</code> the maximum number of levels we want in the pruned
 entity.  Use 1 for the entity itself, 2 for the entity and its children,
 etc.  This attribute is secondary to the include or select attributes.
 The default is 1.<br>
 It is important to remember that pruning is done outside a transaction.
 Specifying an include or select will <b>not</b> cause the EntityPruner
 to fetch missing data from the database.  If you are specifying 
 options, you should probably call 
 <CODE>EntityUtil#populateEntity(Persistable, Map)</CODE>
 to make sure all the desired children are present.
 <p>
 When specifying both a depth and options, the <code>EntityPruner</code>
 will include collections in the options, and then prune them to the 
 given depth.
<P>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE><A HREF="../../../com/saliman/entitypruner/EntityPruner.html#prune(com.saliman.entitypruner.PrunableEntity, java.util.Map)">prune</A></CODE> in interface <CODE><A HREF="../../../com/saliman/entitypruner/EntityPruner.html" title="interface in com.saliman.entitypruner">EntityPruner</A></CODE></DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>entity</CODE> - the <A HREF="../../../com/saliman/entitypruner/PrunableEntity.html" title="interface in com.saliman.entitypruner"><CODE>PrunableEntity</CODE></A> to pruned<DD><CODE>options</CODE> - a map of options and values, patterned after the Ruby on
        Rails conventions.
<DT><B>Throws:</B>
<DD><CODE>java.lang.IllegalStateException</CODE> - if there is a problem.</DL>
</DD>
</DL>
<HR>

<A NAME="unprune(com.saliman.entitypruner.PrunableEntity)"><!-- --></A><H3>
unprune</H3>
<PRE>
public void <B>unprune</B>(<A HREF="../../../com/saliman/entitypruner/PrunableEntity.html" title="interface in com.saliman.entitypruner">PrunableEntity</A>&nbsp;entity)</PRE>
<DL>
<DD>Un-prune the given entity so it can be saved by Hibernate.  Basically
 this means replacing <code>null</code> collections with new 
 <code>PersistentBag</code> objects so that hibernate doesn't try to 
 cascade saves to children. If the entity has an initialized collection
 of children, this method will attempt to detect if it is a bidirectional
 relationship and set the parent in each child before un-pruning each
 child.
 <p>
 This works well enough to save an entity, but not well enough to 
 use the un-pruned entity to get previously uninitialized collections.
 <p>
 Hibernate needs a session to create Proxy collections, so this method
 will make sure there is one to make sure we can un-prune even if we
 are un-pruning from a non-transactional service layer.
<P>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE><A HREF="../../../com/saliman/entitypruner/EntityPruner.html#unprune(com.saliman.entitypruner.PrunableEntity)">unprune</A></CODE> in interface <CODE><A HREF="../../../com/saliman/entitypruner/EntityPruner.html" title="interface in com.saliman.entitypruner">EntityPruner</A></CODE></DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>entity</CODE> - the <A HREF="../../../com/saliman/entitypruner/PrunableEntity.html" title="interface in com.saliman.entitypruner"><CODE>PrunableEntity</CODE></A> to un-prune
<DT><B>Throws:</B>
<DD><CODE>java.lang.IllegalStateException</CODE> - if something goes wrong</DL>
</DD>
</DL>
<!-- ========= END OF CLASS DATA ========= -->
<HR>


<!-- ======= START OF BOTTOM NAVBAR ====== -->
<A NAME="navbar_bottom"><!-- --></A>
<A HREF="#skip-navbar_bottom" title="Skip navigation links"></A>
<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0" SUMMARY="">
<TR>
<TD COLSPAN=2 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
<A NAME="navbar_bottom_firstrow"><!-- --></A>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3" SUMMARY="">
  <TR ALIGN="center" VALIGN="top">
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../com/saliman/entitypruner/package-summary.html"><FONT CLASS="NavBarFont1"><B>Package</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell1Rev"> &nbsp;<FONT CLASS="NavBarFont1Rev"><B>Class</B></FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="class-use/EntityPrunerHibernateJpa.html"><FONT CLASS="NavBarFont1"><B>Use</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-tree.html"><FONT CLASS="NavBarFont1"><B>Tree</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../deprecated-list.html"><FONT CLASS="NavBarFont1"><B>Deprecated</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../index-all.html"><FONT CLASS="NavBarFont1"><B>Index</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../help-doc.html"><FONT CLASS="NavBarFont1"><B>Help</B></FONT></A>&nbsp;</TD>
  </TR>
</TABLE>
</TD>
<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>
<h3>Entiy Pruner</h3></EM>
</TD>
</TR>

<TR>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
&nbsp;<A HREF="../../../com/saliman/entitypruner/EntityPruner.html" title="interface in com.saliman.entitypruner"><B>PREV CLASS</B></A>&nbsp;
&nbsp;<A HREF="../../../com/saliman/entitypruner/EntityUtil.html" title="class in com.saliman.entitypruner"><B>NEXT CLASS</B></A></FONT></TD>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
  <A HREF="../../../index.html?com/saliman/entitypruner/EntityPrunerHibernateJpa.html" target="_top"><B>FRAMES</B></A>  &nbsp;
&nbsp;<A HREF="EntityPrunerHibernateJpa.html" target="_top"><B>NO FRAMES</B></A>  &nbsp;
&nbsp;<SCRIPT type="text/javascript">
  <!--
  if(window==top) {
    document.writeln('<A HREF="../../../allclasses-noframe.html"><B>All Classes</B></A>');
  }
  //-->
</SCRIPT>
<NOSCRIPT>
  <A HREF="../../../allclasses-noframe.html"><B>All Classes</B></A>
</NOSCRIPT>


</FONT></TD>
</TR>
<TR>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
  SUMMARY:&nbsp;NESTED&nbsp;|&nbsp;FIELD&nbsp;|&nbsp;<A HREF="#constructor_summary">CONSTR</A>&nbsp;|&nbsp;<A HREF="#method_summary">METHOD</A></FONT></TD>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
DETAIL:&nbsp;FIELD&nbsp;|&nbsp;<A HREF="#constructor_detail">CONSTR</A>&nbsp;|&nbsp;<A HREF="#method_detail">METHOD</A></FONT></TD>
</TR>
</TABLE>
<A NAME="skip-navbar_bottom"></A>
<!-- ======== END OF BOTTOM NAVBAR ======= -->

<HR>
<i>Copyright &#169; 2008 Steven C. Saliman All Rights Reserved.</i>
</BODY>
</HTML>
